<!DOCTYPE html>
<html lang="en">
<head>
  <meta charset="UTF-8" />
  <meta name="viewport" content="width=device-width, initial-scale=1.0" />
  <title>SIMD Brightness Filter (WASM)</title>
  <style>
    body { font-family: Arial, sans-serif; background: #111; color: #fff; text-align: center; padding: 2rem; }
    canvas { margin-top: 1rem; border-radius: 10px; box-shadow: 0 0 10px rgba(255,255,255,0.08); max-width: 100%; height: auto; }
    button, input[type="range"], input[type="number"] { margin: 6px; padding: 8px 12px; background: #ff6600; border: none; color: white; border-radius: 6px; cursor: pointer; }
    input[type="range"] { appearance: none; width: 220px; padding: 6px; background: #333; }
    input[type="number"] { width: 70px; background: #222; color: #fff; border-radius: 6px; padding: 6px; border: 1px solid #333; }
    button:hover { background: #ff8800; }
    #info { margin-top: 1rem; font-size: 1.0rem; color: #ffcc66; }
    #timing { margin-top: 0.5rem; font-size: 0.95rem; color: #aaffaa; }
    .controls { margin-top: 12px; }
  </style>
</head>
<body>
  <h1>⚡ SIMD Brightness Filter (WASM)</h1>

  <input type="file" id="upload" accept="image/*" />
  <div class="controls">
    <label for="brightness">Brightness</label>
    <input id="brightness" type="range" min="-255" max="255" value="40" />
    <input id="brightnessNum" type="number" min="-255" max="255" value="40" />
  </div>

  <div class="controls">
    <button id="scalar">Apply Scalar (JS)</button>
    <button id="simd" disabled>Apply SIMD (WASM)</button>
    <button id="reset">Reset Image</button>
  </div>

  <div id="info">No image loaded yet.</div>
  <div id="timing"></div>
  <canvas id="canvas" width="200" height="200"></canvas>

  <script>
    // Provide a simple Module stub so non-modularized Emscripten builds can call onRuntimeInitialized.
    window.Module = window.Module || {};
    if (!window.Module.onRuntimeInitialized) {
      window.Module.onRuntimeInitialized = function() {
        const simdBtn = document.getElementById("simd");
        if (simdBtn) simdBtn.disabled = false;
        document.getElementById("info").textContent = "WASM ready. Upload an image to begin.";
      };
    }
  </script>

  <script src="simd_image_filter.js"></script>

  <script>
    const TARGET_SIZE = 200;
    const upload = document.getElementById("upload");
    const canvas = document.getElementById("canvas");
    const ctx = canvas.getContext("2d");
    const info = document.getElementById("info");
    const timing = document.getElementById("timing");
    const brightnessRange = document.getElementById("brightness");
    const brightnessNum = document.getElementById("brightnessNum");
    const simdBtn = document.getElementById("simd");
    const scalarBtn = document.getElementById("scalar");

    let imgData = null;
    let originalData = null;

    // timing
    let lastScalarTime = null;
    let lastWasmTotalTime = null;
    let lastWasmExecTime = null;

    // reused WASM buffer to avoid repeated malloc/free
    let wasmPtr = 0;
    let wasmBufSize = 0;

    brightnessRange.addEventListener("input", () => brightnessNum.value = brightnessRange.value);
    brightnessNum.addEventListener("input", () => brightnessRange.value = brightnessNum.value);

    function loadAndScaleImage(img) {
      canvas.width = TARGET_SIZE;
      canvas.height = TARGET_SIZE;
      ctx.clearRect(0, 0, TARGET_SIZE, TARGET_SIZE);
      ctx.drawImage(img, 0, 0, TARGET_SIZE, TARGET_SIZE);
      imgData = ctx.getImageData(0, 0, TARGET_SIZE, TARGET_SIZE);
      originalData = new Uint8ClampedArray(imgData.data);
      info.textContent = `Image Loaded — scaled to ${TARGET_SIZE}×${TARGET_SIZE}`;
      timing.textContent = '';
      lastScalarTime = lastWasmTotalTime = lastWasmExecTime = null;
    }

    upload.addEventListener("change", (e) => {
      const file = e.target.files && e.target.files[0];
      if (!file) return;
      const img = new Image();
      img.crossOrigin = "anonymous";
      img.onload = () => loadAndScaleImage(img);
      img.onerror = () => info.textContent = "Error loading image.";
      img.src = URL.createObjectURL(file);
    });
    // Scalar Js function
    function applyScalarJS() {
      if (!imgData || !originalData) { alert("Upload an image first."); return; }
      const brightness = parseInt(brightnessRange.value, 10) || 0;
      const len = imgData.data.length;
      const src = originalData;
      const dst = new Uint8ClampedArray(len);
      const start = performance.now();
      for (let i = 0; i < len; i += 4) {
        let r = src[i] + brightness; r = r < 0 ? 0 : (r > 255 ? 255 : r);
        let g = src[i+1] + brightness; g = g < 0 ? 0 : (g > 255 ? 255 : g);
        let b = src[i+2] + brightness; b = b < 0 ? 0 : (b > 255 ? 255 : b);
        dst[i] = r; dst[i+1] = g; dst[i+2] = b; dst[i+3] = src[i+3];
      }
      const end = performance.now();
      imgData.data.set(dst);
      ctx.putImageData(imgData, 0, 0);
      lastScalarTime = end - start;
      info.textContent = `JS scalar applied in ${lastScalarTime.toFixed(2)} ms — brightness ${brightness}`;
      updateTimingDisplay();
    }

    // wait for wasm runtime (accepts modularized or global builds)
    function waitForWasmReady(timeoutMs = 7000) {
      return new Promise((resolve, reject) => {
        const start = performance.now();
        (function check() {
          if (window.Module && (typeof Module._malloc === 'function' || typeof Module.ccall === 'function')) {
            if (!Module.HEAPU8 && (Module.buffer || (Module.wasmMemory && Module.wasmMemory.buffer))) {
              Module.HEAPU8 = new Uint8Array(Module.buffer || Module.wasmMemory.buffer);
            }
            return resolve(window.Module);
          }
          if (performance.now() - start > timeoutMs) return reject(new Error('WASM did not initialize within timeout'));
          setTimeout(check, 50);
        })();
      });
    }

    function ensureWasmBuffer(size) {
      if (!Module || typeof Module._malloc !== 'function') throw new Error('WASM not ready');
      if (wasmBufSize >= size && wasmPtr) return wasmPtr;
      if (wasmPtr) { try { Module._free(wasmPtr); } catch(e) {} wasmPtr = 0; wasmBufSize = 0; }
      wasmPtr = Module._malloc(size);
      if (!wasmPtr) throw new Error('WASM malloc failed');
      wasmBufSize = size;
      if (!Module.HEAPU8) Module.HEAPU8 = new Uint8Array(Module.buffer || (Module.wasmMemory && Module.wasmMemory.buffer));
      return wasmPtr;
    }

    async function applyWasm(funcName) {
      if (!imgData || !originalData) { alert("Upload an image first."); return; }

      try {
        await waitForWasmReady();
      } catch (e) {
        alert("WASM not ready yet. Please wait a moment and try again.");
        console.error(e);
        return;
      }

      if (!Module || typeof Module._malloc !== "function" || typeof Module.ccall !== "function") {
        alert("WASM runtime missing required functions (_malloc/ccall). Rebuild with EXPORTED_RUNTIME_METHODS.");
        return;
      }

      const brightness = parseInt(brightnessRange.value, 10) || 0;
      const length = imgData.data.length;
      let ptr;
      try { ptr = ensureWasmBuffer(length); } catch (e) { console.error(e); alert("WASM malloc failed. See console."); return; }

      try {
        // copy original into tmp, set alpha=255 to avoid wasm changing transparency
        const tmp = new Uint8Array(length);
        tmp.set(originalData);
        for (let i = 3; i < length; i += 4) tmp[i] = 255;

        if (!Module.HEAPU8) {
          if (Module.buffer) Module.HEAPU8 = new Uint8Array(Module.buffer);
          else if (Module.wasmMemory && Module.wasmMemory.buffer) Module.HEAPU8 = new Uint8Array(Module.wasmMemory.buffer);
        }

        if (!Module.HEAPU8 || (ptr + tmp.length > Module.HEAPU8.length)) {
          alert('WASM heap unavailable or too small. Rebuild with ALLOW_MEMORY_GROWTH / increase TOTAL_MEMORY.');
          return;
        }

        const t0 = performance.now();
        Module.HEAPU8.set(tmp, ptr);
        const copyEnd = performance.now();

        const execStart = performance.now();
        Module.ccall(funcName, "void", ["number","number","number"], [ptr, length, brightness]);
        const execEnd = performance.now();

        // restore original alpha bytes in-place so ImageData has correct alpha
        for (let i = 3; i < length; i += 4) Module.HEAPU8[ptr + i] = originalData[i];

        // create a view directly on wasm memory and draw (may still copy internally in some browsers)
        const view = new Uint8ClampedArray(Module.HEAPU8.buffer, ptr, length);
        const readEnd = performance.now();
        ctx.putImageData(new ImageData(view, TARGET_SIZE, TARGET_SIZE), 0, 0);

        lastWasmTotalTime = (readEnd - t0);     // includes copy, exec, readback
        lastWasmExecTime = (execEnd - execStart); // ccall time only

        info.textContent = `WASM applied: exec ${lastWasmExecTime.toFixed(2)} ms, total ${lastWasmTotalTime.toFixed(2)} ms — brightness ${brightness}`;
        updateTimingDisplay();
      } finally {
        // keep buffer allocated for reuse (faster). To free: Module._free(wasmPtr); wasmPtr=0; wasmBufSize=0;
      }
    }

    function updateTimingDisplay() {
      let text = '';
      if (lastScalarTime != null) text += `JS scalar: ${lastScalarTime.toFixed(2)} ms`;
      if (lastWasmTotalTime != null) {
        if (text) text += ' · ';
        text += `WASM total: ${lastWasmTotalTime.toFixed(2)} ms (exec ${lastWasmExecTime.toFixed(2)} ms)`;
      }
      if (lastScalarTime != null && lastWasmTotalTime != null && lastWasmTotalTime > 0) {
        const speedup = lastScalarTime / lastWasmTotalTime;
        text += ` · Speedup (scalar / wasm_total): ${speedup.toFixed(2)}×`;
      } else if (lastScalarTime != null && lastWasmExecTime != null && lastWasmExecTime > 0) {
        const speedupExec = lastScalarTime / lastWasmExecTime;
        text += ` · Speedup (scalar / wasm_exec): ${speedupExec.toFixed(2)}×`;
      }
      timing.textContent = text;
    }

    scalarBtn.addEventListener("click", () => applyScalarJS());
    simdBtn.addEventListener("click", () => applyWasm("adjustBrightnessSIMD"));

    document.getElementById("reset").addEventListener("click", () => {
      if (!imgData || !originalData) return;
      imgData.data.set(originalData);
      ctx.putImageData(imgData, 0, 0);
      info.textContent = `Image reset to original ${TARGET_SIZE}×${TARGET_SIZE}.`;
      timing.textContent = '';
      lastScalarTime = lastWasmTotalTime = lastWasmExecTime = null;
    });
  </script>
</body>
</html>