<!DOCTYPE html>
<html lang="en">
<head>
  <meta charset="UTF-8" />
  <meta name="viewport" content="width=device-width, initial-scale=1.0" />
  <title>SIMD Brightness Filter (WASM)</title>
  <style>
    body {
      font-family: Arial, sans-serif;
      background: #111;
      color: #fff;
      text-align: center;
      padding: 2rem;
    }
    canvas {
      margin-top: 1rem;
      border-radius: 10px;
      box-shadow: 0 0 10px rgba(255,255,255,0.2);
      max-width: 100%;
      height: auto;
    }
    button, input[type="range"], input[type="number"] {
      margin: 6px;
      padding: 8px 12px;
      background: #ff6600;
      border: none;
      color: white;
      border-radius: 6px;
      cursor: pointer;
    }
    input[type="range"] { appearance: none; width: 220px; padding: 6px; background: #333; }
    input[type="number"] { width: 70px; background: #222; color: #fff; border-radius: 6px; padding: 6px; border: 1px solid #333; }
    button:hover { background: #ff8800; }
    #info { margin-top: 1rem; font-size: 1.0rem; color: #ffcc66; }
    .controls { margin-top: 12px; }
  </style>
</head>
<body>
  <h1>⚡ SIMD Brightness Filter (WASM)</h1>

  <input type="file" id="upload" accept="image/*" />
  <div class="controls">
    <label for="brightness">Brightness</label>
    <input id="brightness" type="range" min="-255" max="255" value="40" />
    <input id="brightnessNum" type="number" min="-255" max="255" value="40" />
  </div>

  <div class="controls">
    <button id="scalar">Apply Scalar (JS)</button>
    <button id="simd" disabled>Apply SIMD (WASM)</button>
    <button id="reset">Reset Image</button>
  </div>

  <div id="info">No image loaded yet.</div>
  <canvas id="canvas" width="200" height="200"></canvas>

 <script>
  // Define the global Module object BEFORE loading the wasm glue code
  window.Module = {
    onRuntimeInitialized() {
      console.log("WASM Loaded");
      window.ModuleReady = true;

      const simdBtn = document.getElementById("simd");
      if (simdBtn) simdBtn.disabled = false;
      document.getElementById("info").textContent = "WASM ready. Upload an image to begin.";
    }
  };
</script>

<!-- Load the generated Emscripten JS file -->
  <script src="simd_image_filter.js"></script>

  <script>
    const TARGET_SIZE = 200;

    const upload = document.getElementById("upload");
    const canvas = document.getElementById("canvas");
    const ctx = canvas.getContext("2d");
    const info = document.getElementById("info");
    const brightnessRange = document.getElementById("brightness");
    const brightnessNum = document.getElementById("brightnessNum");
    const simdBtn = document.getElementById("simd");
    const scalarBtn = document.getElementById("scalar");
    let imgData = null;
    let originalData = null;

    // keep range and number synced
    brightnessRange.addEventListener("input", () => brightnessNum.value = brightnessRange.value);
    brightnessNum.addEventListener("input", () => brightnessRange.value = brightnessNum.value);

    // Force canvas to TARGET_SIZE and scale incoming image to fit
    function loadAndScaleImage(img) {
      canvas.width = TARGET_SIZE;
      canvas.height = TARGET_SIZE;
      // draw image scaled to 200x200
      ctx.clearRect(0, 0, TARGET_SIZE, TARGET_SIZE);
      ctx.drawImage(img, 0, 0, TARGET_SIZE, TARGET_SIZE);
      imgData = ctx.getImageData(0, 0, TARGET_SIZE, TARGET_SIZE);
      originalData = new Uint8ClampedArray(imgData.data); // keep a pristine copy
      info.textContent = `Image Loaded — scaled to ${TARGET_SIZE}×${TARGET_SIZE}`;
    }

    upload.addEventListener("change", (e) => {
      const file = e.target.files && e.target.files[0];
      if (!file) return;
      const img = new Image();
      img.onload = () => loadAndScaleImage(img);
      img.onerror = () => info.textContent = "Error loading image.";
      // ensure cross-origin safe URL creation
      img.src = URL.createObjectURL(file);
    });

    // JS scalar implementation — works immediately after image load
    function applyScalarJS() {
      if (!imgData || !originalData) {
        alert("Upload an image first.");
        return;
      }
      const brightness = parseInt(brightnessRange.value, 10) || 0;
      const len = imgData.data.length;
      const src = originalData;
      const dst = new Uint8ClampedArray(len);

      const start = performance.now();
      for (let i = 0; i < len; i++) {
        let v = src[i] + brightness;
        if (v < 0) v = 0;
        else if (v > 255) v = 255;
        dst[i] = v;
      }
      const end = performance.now();

      imgData.data.set(dst);
      ctx.putImageData(imgData, 0, 0);
      info.textContent = `JS scalar applied in ${(end - start).toFixed(2)} ms — brightness ${brightness}`;
    }

    // Call WASM export (simd or scalar compiled in C)
    // ...existing code...
    // helper: wait for wasm runtime to be ready (safe if _wasmInit missing)
    function waitForWasmReady(timeoutMs = 7000) {
      return new Promise((resolve, reject) => {
        const start = performance.now();

        function check() {
          // If the page provided the helper and it's ready, resolve
          if (window._wasmInit && window._wasmInit.ready) {
            return resolve(window.Module);
          }
          // If Module already exposes required runtime methods, resolve
          if (window.Module && (typeof Module._malloc === 'function' || typeof Module.ccall === 'function')) {
            // ensure Module.HEAPU8 exists (some builds don't attach it to Module)
            if (!Module.HEAPU8 && (Module.buffer || (Module.wasmMemory && Module.wasmMemory.buffer))) {
              Module.HEAPU8 = new Uint8Array((Module.buffer || Module.wasmMemory.buffer));
            }
            return resolve(window.Module);
          }
          if (performance.now() - start > timeoutMs) {
            return reject(new Error('WASM did not initialize within timeout'));
          }
          setTimeout(check, 50);
        }
        check();
      });
    }

    async function applyWasm(funcName) {
      if (!imgData || !originalData) { alert("Upload an image first."); return; }

      try {
        await waitForWasmReady();
      } catch (e) {
        alert("WASM not ready yet. Please wait a moment and try again.");
        console.error(e);
        return;
      }

      if (!Module || typeof Module._malloc !== "function" || typeof Module.ccall !== "function") {
        alert("WASM runtime missing required functions (_malloc/ccall). Rebuild with EXPORTED_RUNTIME_METHODS.");
        return;
      }

      const brightness = parseInt(brightnessRange.value, 10) || 0;
      const length = imgData.data.length;
      const ptr = Module._malloc(length);
      if (!ptr) { alert("WASM malloc failed."); return; }

      try {
        const tmp = new Uint8Array(length);
        tmp.set(originalData);
        for (let i = 3; i < length; i += 4) tmp[i] = 255;

        if (!Module.HEAPU8) {
          if (Module.buffer) Module.HEAPU8 = new Uint8Array(Module.buffer);
          else if (Module.wasmMemory && Module.wasmMemory.buffer) Module.HEAPU8 = new Uint8Array(Module.wasmMemory.buffer);
        }

        if (!Module.HEAPU8 || (ptr + tmp.length > Module.HEAPU8.length)) {
          alert('WASM heap unavailable or too small. Rebuild with ALLOW_MEMORY_GROWTH / export runtime methods.');
          return;
        }

        Module.HEAPU8.set(tmp, ptr);

        const start = performance.now();
        Module.ccall(funcName, "void", ["number","number","number"], [ptr, length, brightness]);
        const end = performance.now();

        const elapsed = (end - start).toFixed(2);
        info.textContent = `${funcName} applied in ${elapsed} ms — brightness ${brightness}`;

        const result = Module.HEAPU8.subarray(ptr, ptr + length);
        for (let i = 0; i < length; i += 4) {
          imgData.data[i]   = result[i];
          imgData.data[i+1] = result[i+1];
          imgData.data[i+2] = result[i+2];
          imgData.data[i+3] = originalData[i+3];
        }
        ctx.putImageData(imgData, 0, 0);
      } finally {
        try { Module._free(ptr); } catch (e) { console.warn('free failed', e); }
      }
    }

    scalarBtn.addEventListener("click", () => applyScalarJS());
    simdBtn.addEventListener("click", () => applyWasm("adjustBrightnessSIMD"));

    document.getElementById("reset").onclick = () => {
      if (!imgData || !originalData) return;
      imgData.data.set(originalData);
      ctx.putImageData(imgData, 0, 0);
      info.textContent = `Image reset to original ${TARGET_SIZE}×${TARGET_SIZE}.`;
    };
  </script>
</body>
</html>
